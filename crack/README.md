# Свой crackme

Задача заключалась в написании программы на ассемблере под ОС MS-DOS для взлома. В ней нужно было предусмотреть 2 уязвимости: легкую и сложную. Пользователю даётся только исполняемый файл ```vzlom.com```.

## Работа программы

Пользвателю выводятся приветственные сообщения и после предлагается ввести пароль. Если пароль совпал с тем, что лежит в переменной, тогда выводиться сообщение ```SOSAL```, что означает об успешном завершении программы. В протвном случае выводиться ```NE SOSAL LOX```.

Стоит уточнить, что в условиях было оговорено о непосредственном взломе программы, а просто подсмотреть правильный пароль является тривиальной задачей.

## Лёгкая уязвимость

Для её решения стоит лишь пристально посмотреть дизассемблер программы, чтобы найти данную строчку

![alt text](assets/image.png)

По этой метке счётчик, который используется для проверки пароля, обнуляется, а далее идёт прыжок на место проверки данного счётчика на ноль. Соответственно достаточно ввести в пароль нулевой байт. В MS-DOS это делается на комбинацию клавиш ```Ctrl+@```.

## Тяжёлая уязвимость

Для более изощрённого способа взлома нужно будет 
написать вспомогательную программу. 
При выводе текста используются функции DOS и 
вызывается 09h функция прерывания под номер 21h. 
Нужно написать резидентную программу,
которая вешается на данное прерывание, 
считает количество вызовов данной функции и на 3-ем
вызове меняет IP из стэка на равное месту, где 
выводиться положительный ответ.

```asm
.model tiny
.186
.code
org 100h

Main:
    mov ax, 0h
    mov es, ax
    mov bx, 21h*4

    cli                                 ; Start of changing

    mov ax, word ptr es:[bx]
    mov RealDOSOfs, ax
    mov ax, word ptr es:[bx+2]
    mov RealDOSSeg, ax                  ; Save the address of previous Time Controller
    mov es:[bx], offset DOSint
    mov es:[bx+2], cs                   ; Load the address of my Time Controller

    sti                                 ; End of changing

    mov ax, 3100h
    mov dx, offset EndLabel
    shr dx, 4
    inc dx
    int 21h                             ; Stop and stay resident

DOSint  proc

    cmp ah, 09h
    je Rofl

Continue:
    db 0eah                             ; Jump to real DOS int Controller
RealDOSOfs dw 0h
RealDOSSeg dw 0h

Rofl:
    inc cs:[Count]

    cmp cs:[Count], 03h
    je Lomaem

    jmp Continue

Lomaem:

    push ax bx es

    mov ax, 0h
    mov es, ax
    mov bx, 21h*4

    mov ax, cs:[RealDOSOfs]
    mov es:[bx], ax
    mov ax, cs:[RealDOSSeg]
    mov es:[bx+2], ax

    pop es bx ax

    pop cs:[Save_ip]
    push 013dh

    push ax
    mov ax, 20h
    out 20h, ax
    pop ax

    retf 2

endp

Count db 0h
Save_cs dw 0h
Save_ip dw 0h

EndLabel:

end Main
```

# Взлом чужой crackme

Мне был дан файл crackme.com. При вводе неправильного ответа выводиться ```DAUN POIMAN```.
При правильном ответе выводиться ```LEGENDA GONOK```.

## Лёгкая уязвимость
Первое, что я решил попробовать, это ввод большого 
количества символов в пароль. После 10-ого символа на каждый ввод звучит писк и ничего не вводиться. 
Это намекает на то, что можно будет попробовать переполнить буффер и перезаписать значения.

После этого проверил ввод 0-ого байта и пустой ввод,
как очевидные неточности. Пустой ввод сработал в качестве правильного ответа и лёгкая уязвимость была найдена.

## Сложная уязвимость
Начав исполнять в отладчике программу я понял,
что автор добавил туда много отвлекающих бессмысленных элементов и функций, чтобы было менее
понятно что происходит в программе. Я дошёл до вызова функции считывания пароля и ввёл символы ascii-код которых я знаю (11), чтобы понять куда будет записываться пароль

![alt text](assets/image2.png)

Проанализировав окно отладчика я понял, что введённый пароль кладётся в стэк. А значит 
можно будет перезаписать адресс возврата из вызванной функции и переместиться на вывод правильного ответа.

![alt text](assets/image3.png)

Остаётся найти место вывода правильного ответа, адрес которого нужно будет записать в пароль.
Я нашёл единственное место, где происходит сравнение.

![alt text](assets/image4.png)

Проанализировав его, я понял, что сравниваются только 3 символа, и если они совпадают идёт jmp по адресу 014A. Подтвердил это пройдя дебагером данный код с пустым вводом из лёгкой уязвимости.

Следовательно нужно ввести ```(char)01h = Ctrl+A``` и ```(char)4Ah = J```, но только в обратном порядке. 

![alt text](assets/image5.png)

Взлом выполнен.
