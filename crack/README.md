# Условия
В данной задаче нужно было написать программу, принимающую пароль пользователя. Если пароль оказался
верным, то нужно вывести положительный ответ, иначе - отрицательный. В данной программе нужно было
предусмотреть 2 уязвимости  для взлома пользователем: 1 лёгкую и 1 тяжёлую.

В качестве операционной системы использовалась виртуальная машина MS-DOS, так как в ней без ограничений можно
распоряжаться практически всеми предоставляемыми ресурсами и памятью. Это помогает лучше понять работу
ассемблера, оперативной памяти и устройства операционных систем. После работы на MS-DOS намного легче
будет перейти на актуальные операционные системы и современный ассемблер.

# Свой crackme

Задача заключалась в написании программы на ассемблере под ОС MS-DOS для взлома. В ней нужно было предусмотреть 2 уязвимости: легкую и сложную. Пользователю даётся только исполняемый файл ```vzlom.com```.

## Работа программы

Пользователю выводятся приветственные сообщения и после предлагается ввести пароль. Если пароль совпал с тем, что лежит в переменной, тогда выводиться сообщение ```CORRECT```, что означает об успешном завершении программы. В противном случае выводится ```INCORRECT```.

Стоит уточнить, что в условиях задачи было сказано именно о взломе программы, то есть целью является
нарушение работы программы, а просто подсмотреть правильный пароль является тривиальной задачей.

## Лёгкая уязвимость

Для её решения стоит лишь пристально посмотреть дизассемблер программы, чтобы найти данную строчку

```asm
cmp byte ptr [016A], 0
je 013D
```

По этой метке счётчик, который используется для проверки пароля, обнуляется, а далее идёт прыжок на место проверки данного счётчика на ноль. Соответственно достаточно ввести в пароль нулевой байт. В MS-DOS это делается на комбинацию клавиш ```Ctrl+@```.

## Тяжёлая уязвимость

Для более изощрённого способа взлома нужно будет 
написать вспомогательную программу. 
При выводе текста используются функции DOS и 
вызывается 09h функция прерывания под номер 21h. 
Нужно написать резидентную программу,
которая вешается на данное прерывание, 
считает количество вызовов данной функции и на 3-ем
вызове меняет IP из стека на равное месту, где 
выводиться положительный ответ.

```asm
.model tiny
.186
.code
org 100h

Main:
    mov ax, 0h
    mov es, ax
    mov bx, 21h*4

    cli                                 ; Start of changing

    mov ax, word ptr es:[bx]
    mov RealDOSOfs, ax
    mov ax, word ptr es:[bx+2]
    mov RealDOSSeg, ax                  ; Save the address of previous Time Controller
    mov es:[bx], offset DOSint
    mov es:[bx+2], cs                   ; Load the address of my Time Controller

    sti                                 ; End of changing

    mov ax, 3100h
    mov dx, offset EndLabel
    shr dx, 4
    inc dx
    int 21h                             ; Stop and stay resident

DOSint  proc

    cmp ah, 09h
    je Rofl

Continue:
    db 0eah                             ; Jump to real DOS int Controller
RealDOSOfs dw 0h
RealDOSSeg dw 0h

Rofl:
    inc cs:[Count]

    cmp cs:[Count], 03h
    je Lomaem

    jmp Continue

Lomaem:

    push ax bx es

    mov ax, 0h
    mov es, ax
    mov bx, 21h*4

    mov ax, cs:[RealDOSOfs]
    mov es:[bx], ax
    mov ax, cs:[RealDOSSeg]
    mov es:[bx+2], ax

    pop es bx ax

    pop cs:[Save_ip]
    push 013dh

    push ax
    mov ax, 20h
    out 20h, ax
    pop ax

    retf 2

endp

Count db 0h
Save_cs dw 0h
Save_ip dw 0h

EndLabel:

end Main
```

# Взлом чужой crackme

Мне был дан файл crackme.com. При вводе неправильного ответа выводиться ```I GOT YOU```.
При правильном ответе выводиться ```YOU ARE A LIVING LEGEND```.

## Лёгкая уязвимость
Первое, что я решил попробовать, это ввод большого 
количества символов в пароль. После 10-ого символа на каждый ввод звучит писк и ничего не вводиться. 
Это намекает на то, что можно будет попробовать переполнить буфер и перезаписать значения.

После этого проверил ввод 0-ого байта и пустой ввод,
как очевидные неточности. Пустой ввод сработал в качестве правильного ответа и лёгкая уязвимость была найдена.

## Сложная уязвимость
Начав исполнять в отладчике программу я понял,
что автор добавил туда много отвлекающих бессмысленных элементов и функций, чтобы было менее
понятно что происходит в программе. Я дошёл до вызова функции считывания пароля и ввёл символы ascii-код которых я знаю (11), чтобы понять куда будет записываться пароль

![alt text](assets/image2.png)

Проанализировав окно отладчика я понял, что введённый пароль кладётся в стек. А значит 
можно будет перезаписать адрес возврата из вызванной функции и переместиться на вывод правильного ответа.

![alt text](assets/image3.png)

Остаётся найти место вывода правильного ответа, адрес которого нужно будет записать в пароль.
Я нашёл единственное место, где происходит сравнение.

![alt text](assets/image4.png)

Проанализировав его, я понял, что сравниваются только 3 символа, и если они совпадают идёт jmp по адресу 014A. Подтвердил это пройдя дебагером данный код с пустым вводом из лёгкой уязвимости.

Следовательно нужно ввести ```(char)01h = Ctrl+A``` и ```(char)4Ah = J```, но только в обратном порядке. 

![alt text](assets/image5.png)

Взлом выполнен.

## Дизассемблеры

Для дальнейших задач потребуется использовать более продвинутые инструменты reverse-инжиниринга по
сравнению с Turbo дебагером. Поэтому на данной crackme я рассмотрел работу различных дизассемблеров, 
чтобы сравнить минусы и плюсы.

### IDA Free

#### Плюсы

![alt text](assets/image6.png)

Сразу бросаются в глаза комментарии к функциям DOS, в которых прописано что это за функция 
и какие аргументы через какие регистры она принимает. Названия функций компактные и по ним можно 
понять адрес начала.

![alt text](assets/image7.png)

К каждой функции можно перейти по клику, а также перед определением функции есть кликабельные ссылки
на места, где она вызывается.

В общем, подсветка, удобство перемещения и информация о функциях DOS позволяет быстро
"въехать", что происходит в программе.

IDA Free поддерживает широкий спектр процессорных архитектур, что делает её универсальным инструментом для анализа различных типов бинарных файлов. А также IDA поддерживает множество плагинов, которые могут расширить её возможности.

#### Минусы

-   Нет встроенного отладчика. 
-   В бесплатной версии нет возможности восстановить код на языке высокого уровня (конкретно в нашей задаче это не сильно плохо, но для будущих работ является серьёзным минусом).

### Ghidra

![alt text](assets/image8.png)

#### Плюсы

Данный дизассемблер является, наверное, самым комплексным и универсальным инструментом. Есть огромное количество функций для анализа и редактирования различной информации в листинге. Есть возможность декомпиляции в языка высокого уровня (и соответственно анализ ассемблерного листинга с учётом того, что он был написан компилятором). Визуальное указание jump-ов и наличие кликабельных референсов у функций.

Ghidra является открытым проектом, поэтому на данную утилиту существует много плагинов под различные нужды, что может сильно упростить работу над конкретным проектом и позволяет расширить и без того большой функционал.

Есть возможность написания скриптов на Java и Python, что позволяет автоматизировать многие задачи анализа.
#### Минусы

-   Сложность в установке
-   Интуитивно непонятный интерфейс
-   Отсутствие встроенного дебагера
-   Требовательно к ресурсам компьютера

### Radar2

![alt text](assets/image9.png)

#### Плюсы

-   Работает из консоли
-   Очень удобный удобный интерфейс с возможностью кастомизации и неимоверным количеством hotkey-ев (vim moment)
-   Есть встроенный дебагер с выводом всей необходимой вспомогательной информации (состояния регистров, стека и т.д.)
-   Кликабельный ссылки на функции (а также выделение их области)
-   Если постараться, можно прикрутить к такой классной визуальной составляющей функционал Ghidra

#### Минусы

-   Нет возможности декомпиляции в язык высокого уровня
-   У меня не работает дебагер